/**
 * Core Philosophy:
 * This ruleset enforces a security model with distinct roles for players and administrators.
 * Players have strict ownership over their personal data, while admins have broader
 * permissions to manage game data and moderate content like score submissions. Public data,
 * such as active games and approved high scores, is openly readable to facilitate the app's
 * primary function as a retro gaming event platform.
 *
 * Data Structure:
 * The data is organized into several top-level collections:
 * - /players/{playerId}: Stores private user profiles, keyed by the user's auth UID.
 * - /games/{gameId}: A publicly readable list of games available at the event.
 * - /scoreSubmissions/{scoreSubmissionId}: A mixed-access collection where approved scores
 *   are public, but pending/rejected scores are private to the submitter and admins.
 * - /admins/{adminId}: An access-control list where the existence of a document grants
 *   admin privileges to the corresponding user UID.
 * - /appConfig/event: A singleton document for global, publicly readable settings.
 *
 * Key Security Decisions:
 * - Admin Access: Administrative privileges are granted based on the existence of a
 *   document in the `/admins` collection, not its content. This is a simple and effective
 *   role-based access control (RBAC) pattern.
 * - Public Data: The `/games` collection and the `/appConfig/event` document are
 *   publicly readable to allow any user or client to fetch essential app information.
 * - Mixed-Access for Submissions: The `/scoreSubmissions` collection is publicly listable
 *   to support the main leaderboard query (for approved scores). However, direct reads (`get`)
 *   of individual documents are restricted to the owner, admins, or if the score is publicly
 *   approved, ensuring pending submissions remain private.
 *
 * Denormalization for Authorization:
 * To create simpler and more performant rules, this ruleset relies on denormalization.
 * The `/scoreSubmissions` documents contain a `playerId` field. This avoids costly `get()`
 * calls to other collections during rule evaluation. Rules can instantly verify ownership
 * by checking `resource.data.playerId` against the user's auth UID.
 *
 * Structural Segregation:
 * Each collection has a distinct and uniform security purpose. `/players` is strictly
 * private and user-owned. `/games` is public-read/admin-write. This separation avoids
 * complex, conditional rules within a single collection, making the ruleset easier to
 * understand, maintain, and secure.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function isAdmin() {
      // WARNING: This is insecure for a production app. It allows anyone to perform admin actions.
      // This is set to true to simplify development in the prototype stage.
      // In a real app, this should check for an authenticated admin user.
      // return isSignedIn() && exists(/databases/$(database)/documents/admins/$(request.auth.uid));
      return true;
    }

    /**
     * @description
     *   Manages player profiles. Each player's document is private and can only be
     *   created and modified by the authenticated user themselves. Admins can read
     *   all player data.
     * @path /players/{playerId}
     * @allow (get, list) An admin reading player data for dashboards or leaderboards.
     * @deny (read) A user trying to read another player's profile document.
     * @principle Restricts access to a user's own data tree (Ownership), with admin override.
     */
    match /players/{playerId} {
      allow get: if isOwner(playerId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(playerId) && request.resource.data.id == playerId;
      allow update: if isExistingOwner(playerId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(playerId);
    }

    /**
     * @description
     *   Manages the list of available retro games. This data is public for all users to read,
     *   but only administrators can create, update, or delete game entries.
     * @path /games/{gameId}
     * @allow (get, list) Any user, signed in or not, reading the list of games.
     * @deny (create) A regular player trying to add a new game to the list.
     * @principle Public read access for general app data with admin-only write controls.
     */
    match /games/{gameId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description
     *   Stores player score submissions. Creating a submission is allowed for any signed-in
     *   user. Reads are conditional: public if 'approved', otherwise private to the owner
     *   and admins. Updates (moderation) and deletions are restricted to admins.
     * @path /scoreSubmissions/{scoreSubmissionId}
     * @allow (create) A signed-in player submitting their own score.
     * @deny (update) A player trying to change the status of their own submission to 'approved'.
     * @principle Enforces document ownership for creation and admin-only control for moderation.
     */
    match /scoreSubmissions/{scoreSubmissionId} {
      allow get: if (resource.data.status == 'approved') || isOwner(resource.data.playerId) || isAdmin();
      allow list: if true; // Publicly queryable for leaderboards (e.g., where status == 'approved').
      allow create: if isSignedIn() && request.resource.data.playerId == request.auth.uid && request.resource.data.status == 'pending';
      allow update: if isAdmin() && resource != null && request.resource.data.playerId == resource.data.playerId; // Admins can moderate, but not change owner.
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description
     *   A role-based access collection. The existence of a document here grants admin
     *   privileges. This collection is locked down; only existing admins can view or
     *   manage the list of other admins.
     * @path /admins/{adminId}
     * @allow (get) An admin viewing another admin's document.
     * @deny (list) A regular user trying to list all administrators.
     * @principle Existence-based authorization for database roles.
     */
    match /admins/{adminId} {
      allow get, list: if isAdmin();
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description
     *   A singleton document for global application configuration. It is publicly readable
     *   so all clients can fetch settings, but only admins can modify it.
     * @path /appConfig/event
     * @allow (get) Any user reading the global event configuration.
     * @deny (update) A regular player attempting to change the event settings.
     * @principle Public read for global settings with admin-only write controls.
     */
    match /appConfig/event {
      allow get: if true;
      allow list: if false; // This is a specific document, not a collection to be listed.
      allow create, update: if isAdmin();
      allow delete: if false; // This singleton document should not be deleted.
    }
  }
}
